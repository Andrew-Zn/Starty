# let 
let 生命只在代码块内有效
```
var a = []
for (let i = 0;i <10;i++) {
  a[i] = function () {
    console.log(i);
  }
} 
a[6]();
```
> 每一轮循环的变量i都是重新声明的，它是怎么知道上一轮循环的值，因为js引擎内部会记住上一轮循环的值，初始化本轮循环的值，初始化本轮变量i时，就在上一轮循环的基础上进行计算

另外for循环还有一个特别之处，就是设置循环变量的部分是一个父作用域，而循环体内部是一个单独的子作用域
```
for(let i= 0 ;i <3; i++) {
  let i = 'abc'
  console.log(i)
}
```
## 不存在变量提升
## 暂时性死区
只要块级作用域内存在let，它所声明的变量就绑定了这个区域，不在首外部影响。
```
var tmp = 123;
if (true) {
  tmp = 'abc'
  let tmp ;
}
```
代码中tmp赋值会报错，ES6明确规定，如果区块中存在let 和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域，凡事在声明之前就使用这些变量，就会报错，在代码块内，使用let声明之前，该变量都是不可用的，即使在块外面有个同样名字的全局变量也不行，这称为“暂时性死区”（temporal dead zone TDZ）
> 暂时性死区，意味着typeof 不在百分之一百安全，如果在声明前用typeof 会抛出$\color{red}{RefereError}$（声明前使用也报这个错）。如果一个变量根本没有声明，反而typeof 不会报错